#include "events.h"

#include <linux/input-event-codes.h>
#include <linux/input.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/poll.h>
#include <sys/epoll.h>
#include <unistd.h>
#include <xf86drm.h>

#include "input.h"
#include "render.h"

#define BITSIZE(bits) ((bits + 7) / 8)

// Stores if the key is pressed or not, we need to keep track of this in order to differentiate between
// an initial press and a repeat press
uint8_t KEY_STATUS[BITSIZE(KEY_MAX)] = { 0 };

#define IS_KEY_PRESSED(idx) (KEY_STATUS[(idx)/8] & (1 << ((idx) % 8)))
#define CLEAR_KEY_PRESS(idx) (KEY_STATUS[(idx)/8] &= ~(1 << ((idx) % 8)))
#define MARK_KEY_PRESSED(idx) (KEY_STATUS[(idx)/8] |= (1 << ((idx) % 8)))

typedef struct {
  int fd;
  enum {
    OWM_INPUT_DEVICE_TYPE_KBD,
    OWM_INPUT_DEVICE_TYPE_MOUSE,
    OWM_INPUT_DEVICE_TYPE_DRM
  } type;
} OwmInputDeviceInfo;

typedef struct {
  struct epoll_event *epoll_events;
  size_t count;
  OwmInputDeviceInfo *device_infos;
} OwmEPollFds;

OwmEPollFds OWM_E_POLL_FDS = { 0 };

int owmEvents_setup() {
  const owmKeyboards *keyboards = owmKeyboards_get();
  const owmMice *mice = owmMice_get();
  size_t size = 1 +                 // 1 for render display
                keyboards->count +  // Keyboard input devices
                mice->count;        // Mouse input devices
  OWM_E_POLL_FDS.epoll_events = malloc(sizeof(struct epoll_event) * size);
  OWM_E_POLL_FDS.device_infos = malloc(sizeof(OwmInputDeviceInfo) * size);
  OWM_E_POLL_FDS.count = size;

  // Register render display
  size_t index = 0;
  int drm_fd = owmRenderDisplay_get_fd_card();
  OWM_E_POLL_FDS.device_infos[index].fd = drm_fd;
  OWM_E_POLL_FDS.device_infos[index].type = OWM_INPUT_DEVICE_TYPE_DRM;
  OWM_E_POLL_FDS.epoll_events[index].data.fd = drm_fd;
  OWM_E_POLL_FDS.epoll_events[index].data.ptr = &OWM_E_POLL_FDS.device_infos[index];
  OWM_E_POLL_FDS.epoll_events[index].events = EPOLLIN;
  if (epoll_ctl(epoll_create1(0), EPOLL_CTL_ADD, drm_fd, &OWM_E_POLL_FDS.epoll_events[index])) {
    perror("epoll_ctl: register DMR");
    goto owmEvents_setup_failure;
  }
  index++;

  // Register keyboards
  size_t kbds_to_process = keyboards->count;
  while (kbds_to_process > 0) {
    int kbd_fd = keyboards->fds[kbds_to_process - 1];

    OWM_E_POLL_FDS.device_infos[index].fd = kbd_fd;
    OWM_E_POLL_FDS.device_infos[index].type = OWM_INPUT_DEVICE_TYPE_KBD;
    OWM_E_POLL_FDS.epoll_events[index].data.fd = kbd_fd;
    OWM_E_POLL_FDS.epoll_events[index].data.ptr = &OWM_E_POLL_FDS.device_infos[index];
    OWM_E_POLL_FDS.epoll_events[index].events = EPOLLIN;
    if (epoll_ctl(epoll_create1(0), EPOLL_CTL_ADD, kbd_fd, &OWM_E_POLL_FDS.epoll_events[index])) {
      perror("epoll_ctl: register DMR");
      goto owmEvents_setup_failure;
    }

    index++;
    --kbds_to_process;
  }

  // Register mice
  size_t mice_to_process = mice->count;
  while(mice_to_process > 0) {
    int fd = mice->fds[mice_to_process - 1];

    OWM_E_POLL_FDS.device_infos[index].fd = fd;
    OWM_E_POLL_FDS.device_infos[index].type = OWM_INPUT_DEVICE_TYPE_KBD;
    OWM_E_POLL_FDS.epoll_events[index].data.fd = fd;
    OWM_E_POLL_FDS.epoll_events[index].data.ptr = &OWM_E_POLL_FDS.device_infos[index];
    OWM_E_POLL_FDS.epoll_events[index].events = EPOLLIN;
    index++;
    --mice_to_process;
  }
  return 0;

owmEvents_setup_failure:
  free(OWM_E_POLL_FDS.epoll_events);
  free(OWM_E_POLL_FDS.device_infos);
  return 1;
}

void (*owmEvents_keyboard_key_press_callback)(uint16_t key_code, owmEventKeyEventType event_type) = NULL;
void (*owmEvents_mouse_key_press_callback)(uint16_t key_code, owmEventKeyEventType event_type) = NULL;
void (*owmEvents_mouse_move_callback)(int rel_x, int rel_y) = NULL;

void owmEvents_set_keyboard_key_press_callback(void (*callback)(uint16_t key_code, owmEventKeyEventType event_type)) {
  owmEvents_keyboard_key_press_callback = callback;
}

void owmEvents_set_mouse_key_press_callback(void (*callback)(uint16_t key_code, owmEventKeyEventType event_type)) {
  owmEvents_mouse_key_press_callback = callback;
}

void owmEvents_set_mouse_move_callback(void (*callback)(int rel_x, int rel_y)) {
  owmEvents_mouse_move_callback = callback;
}

owmEventKeyEventType owmEvents_get_key_event_type(uint16_t key_code, bool pressed) {
  if (!pressed) {
    CLEAR_KEY_PRESS(key_code);
    return OWM_EVENT_KEY_EVENT_RELEASE;
  }
  if (IS_KEY_PRESSED(key_code)) {
    return OWM_EVENT_KEY_EVENT_PRESS_REPEATE;
  } else {
    MARK_KEY_PRESSED(key_code);
    return OWM_EVENT_KEY_EVENT_PRESS;
  }
}

void owmEvents_poll() {
  int timeout = owmRenderContext_is_next_frame_buffer_free() ? 10 : -1;
  int num_events = poll(OWM_EVENT_POLL_FDS.pollfds, OWM_EVENT_POLL_FDS.count, timeout);
  if (num_events == 0) {
    return;
  }

  struct pollfd *pfds = OWM_EVENT_POLL_FDS.pollfds;

  // TODO: check for `revents` bits `POLLERR` `POLLHUP` `POLLNVAL` for input hot-unplug or DRM fd errors

  for (size_t kbd_poll_fd_idx = OWM_EVENT_POLL_FDS.input_kbd_start_idx; kbd_poll_fd_idx <= OWM_EVENT_POLL_FDS.input_kbd_end_idx; kbd_poll_fd_idx++) {
    if (pfds[kbd_poll_fd_idx].revents & POLLIN) {
      struct input_event ev;
      while (read(pfds[kbd_poll_fd_idx].fd, &ev, sizeof(ev)) == sizeof(ev)) {
        if (ev.type == EV_KEY) {
          owmEventKeyEventType event_type = owmEvents_get_key_event_type(ev.code, ev.value ? true : false);
          if (owmEvents_keyboard_key_press_callback != NULL) {
            owmEvents_keyboard_key_press_callback(ev.code, event_type);
          }
        }
      }
    }
  }

  for (size_t mice_poll_fd_idx = OWM_EVENT_POLL_FDS.input_mice_start_idx; mice_poll_fd_idx <= OWM_EVENT_POLL_FDS.input_mice_end_idx; mice_poll_fd_idx++) {
    if (pfds[mice_poll_fd_idx].revents & POLLIN) {
      struct input_event ev;
      static int rel_x = 0;
      static int rel_y = 0;
      while (read(pfds[mice_poll_fd_idx].fd, &ev, sizeof(ev)) == sizeof(ev)) {
        if (ev.type == EV_REL) {
          if (ev.code == REL_X) {
            rel_x += ev.value;
          } else if (ev.code == REL_Y) {
            rel_y += ev.value;
          } else if (ev.code == REL_WHEEL) {
            // TODO: handle scroll wheel
          }
        } else if (ev.type == EV_KEY) {
          owmEventKeyEventType event_type = owmEvents_get_key_event_type(ev.code, ev.value ? true : false);
          if (owmEvents_mouse_key_press_callback != NULL) {
            owmEvents_mouse_key_press_callback(ev.code, event_type);
          }
        } else if (ev.type == EV_SYN && ev.code == SYN_REPORT) { // The mouse "packet" is complete. Dispatch total movement
          if (owmEvents_mouse_move_callback != NULL) {
            owmEvents_mouse_move_callback(rel_x, rel_y);
          }
          rel_x = 0;
          rel_y = 0;
        }
      }
    }
  }

  if (pfds[OWM_EVENT_POLL_FDS.display_idx].revents & POLLIN) {
    drmEventContext ev = {
      .version = DRM_EVENT_CONTEXT_VERSION,
      .page_flip_handler = owmRenderContext_page_flip_handler
    };
    drmHandleEvent(pfds[OWM_EVENT_POLL_FDS.display_idx].fd, &ev);
  }
}

void owmEvents_cleanup() {
  free(OWM_E_POLL_FDS.epoll_events);
  free(OWM_E_POLL_FDS.device_infos);
}
