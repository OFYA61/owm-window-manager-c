#include "events.h"

#include <linux/input-event-codes.h>
#include <linux/input.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/poll.h>
#include <sys/epoll.h>
#include <unistd.h>
#include <xf86drm.h>

#include "input.h"
#include "render.h"

#define BITSIZE(bits) ((bits + 7) / 8)

// Stores if the key is pressed or not, we need to keep track of this in order to differentiate between
// an initial press and a repeat press
uint8_t KEY_STATUS[BITSIZE(KEY_MAX)] = { 0 };

#define IS_KEY_PRESSED(idx) (KEY_STATUS[(idx)/8] & (1 << ((idx) % 8)))
#define CLEAR_KEY_PRESS(idx) (KEY_STATUS[(idx)/8] &= ~(1 << ((idx) % 8)))
#define MARK_KEY_PRESSED(idx) (KEY_STATUS[(idx)/8] |= (1 << ((idx) % 8)))

typedef struct {
  int fd;
  enum {
    OWM_INPUT_DEVICE_TYPE_KBD,
    OWM_INPUT_DEVICE_TYPE_MOUSE,
    OWM_INPUT_DEVICE_TYPE_DRM
  } type;
} OwmInputDeviceInfo;

typedef struct {
  int epoll_instance_fd;
  size_t count;
  OwmInputDeviceInfo *device_infos;
} OwmEventPollData;

OwmEventPollData OWM_EVENT_POLL_DATAS = { 0 };

int owmEvents_setup() {
  const owmKeyboards *keyboards = owmKeyboards_get();
  const owmMice *mice = owmMice_get();
  size_t size = 1 +                 // 1 for render display
                keyboards->count +  // Keyboard input devices
                mice->count;        // Mouse input devices
  int epoll_instance_fd = epoll_create1(0);
  struct epoll_event ev;
  
  OWM_EVENT_POLL_DATAS.epoll_instance_fd = epoll_instance_fd;
  OWM_EVENT_POLL_DATAS.device_infos = malloc(sizeof(OwmInputDeviceInfo) * size);
  OWM_EVENT_POLL_DATAS.count = size;

  // Register render display
  size_t index = 0;
  int drm_fd = owmRenderDisplay_get_fd_card();
  OWM_EVENT_POLL_DATAS.device_infos[index].fd = drm_fd;
  OWM_EVENT_POLL_DATAS.device_infos[index].type = OWM_INPUT_DEVICE_TYPE_DRM;
  OWM_EVENT_POLL_DATAS.epoll_events[index].data.fd = drm_fd;
  OWM_EVENT_POLL_DATAS.epoll_events[index].data.ptr = &OWM_EVENT_POLL_DATAS.device_infos[index];
  OWM_EVENT_POLL_DATAS.epoll_events[index].events = EPOLLIN;
  if (epoll_ctl(epoll_instance_fd, EPOLL_CTL_ADD, drm_fd, &OWM_EVENT_POLL_DATAS.epoll_events[index])) {
    perror("epoll_ctl: register DMR");
    goto owmEvents_setup_failure;
  }
  index++;

  // Register keyboards
  size_t kbds_to_process = keyboards->count;
  while (kbds_to_process > 0) {
    int kbd_fd = keyboards->fds[kbds_to_process - 1];

    OWM_EVENT_POLL_DATAS.device_infos[index].fd = kbd_fd;
    OWM_EVENT_POLL_DATAS.device_infos[index].type = OWM_INPUT_DEVICE_TYPE_KBD;
    OWM_EVENT_POLL_DATAS.epoll_events[index].data.fd = kbd_fd;
    OWM_EVENT_POLL_DATAS.epoll_events[index].data.ptr = &OWM_EVENT_POLL_DATAS.device_infos[index];
    OWM_EVENT_POLL_DATAS.epoll_events[index].events = EPOLLIN;
    if (epoll_ctl(epoll_instance_fd, EPOLL_CTL_ADD, kbd_fd, &OWM_EVENT_POLL_DATAS.epoll_events[index])) {
      perror("epoll_ctl: register DMR");
      goto owmEvents_setup_failure;
    }

    index++;
    --kbds_to_process;
  }

  // Register mice
  size_t mice_to_process = mice->count;
  while(mice_to_process > 0) {
    int mouse_fd = mice->fds[mice_to_process - 1];

    OWM_EVENT_POLL_DATAS.device_infos[index].fd = mouse_fd;
    OWM_EVENT_POLL_DATAS.device_infos[index].type = OWM_INPUT_DEVICE_TYPE_MOUSE;
    OWM_EVENT_POLL_DATAS.epoll_events[index].data.fd = mouse_fd;
    OWM_EVENT_POLL_DATAS.epoll_events[index].data.ptr = &OWM_EVENT_POLL_DATAS.device_infos[index];
    OWM_EVENT_POLL_DATAS.epoll_events[index].events = EPOLLIN;
    if (epoll_ctl(epoll_instance_fd, EPOLL_CTL_ADD, mouse_fd, &OWM_EVENT_POLL_DATAS.epoll_events[index])) {
      perror("epoll_ctl: register DMR");
      goto owmEvents_setup_failure;
    }

    index++;
    --mice_to_process;
  }
  return 0;

owmEvents_setup_failure:
  free(OWM_EVENT_POLL_DATAS.device_infos);
  return 1;
}

void (*owmEvents_keyboard_key_press_callback)(uint16_t key_code, owmEventKeyEventType event_type) = NULL;
void (*owmEvents_mouse_key_press_callback)(uint16_t key_code, owmEventKeyEventType event_type) = NULL;
void (*owmEvents_mouse_move_callback)(int rel_x, int rel_y) = NULL;

void owmEvents_set_keyboard_key_press_callback(void (*callback)(uint16_t key_code, owmEventKeyEventType event_type)) {
  owmEvents_keyboard_key_press_callback = callback;
}

void owmEvents_set_mouse_key_press_callback(void (*callback)(uint16_t key_code, owmEventKeyEventType event_type)) {
  owmEvents_mouse_key_press_callback = callback;
}

void owmEvents_set_mouse_move_callback(void (*callback)(int rel_x, int rel_y)) {
  owmEvents_mouse_move_callback = callback;
}

owmEventKeyEventType owmEvents_get_key_event_type(uint16_t key_code, bool pressed) {
  if (!pressed) {
    CLEAR_KEY_PRESS(key_code);
    return OWM_EVENT_KEY_EVENT_RELEASE;
  }
  if (IS_KEY_PRESSED(key_code)) {
    return OWM_EVENT_KEY_EVENT_PRESS_REPEATE;
  } else {
    MARK_KEY_PRESSED(key_code);
    return OWM_EVENT_KEY_EVENT_PRESS;
  }
}

#define MAX_EVENTS_TO_PROCESS 16
struct epoll_event events_to_process[MAX_EVENTS_TO_PROCESS];

void owmEvents_poll() {
  int timeout = owmRenderContext_is_next_frame_buffer_free() ? 10 : -1;

  int num_ready = epoll_wait(
    OWM_EVENT_POLL_DATAS.epoll_instance_fd,
    events_to_process,
    MAX_EVENTS_TO_PROCESS,
    timeout
  );
  printf("Events to handle: %d\n", num_ready);

  for (int i = 0; i < num_ready; ++i) {
    int fd = events_to_process[i].data.fd;
    OwmInputDeviceInfo *device_info = events_to_process[i].data.ptr;
    if (device_info->type == OWM_INPUT_DEVICE_TYPE_DRM) {
      printf("\tDRM\n");
      drmEventContext ev = {
        .version = DRM_EVENT_CONTEXT_VERSION,
        .page_flip_handler = owmRenderContext_page_flip_handler
      };
      drmHandleEvent(fd, &ev);
    }

    if (device_info->type == OWM_INPUT_DEVICE_TYPE_KBD) {
      printf("\tKEYBOARD\n");
      struct input_event ev;
      while (read(fd, &ev, sizeof(ev)) == sizeof(ev)) {
        if (ev.type == EV_KEY) {
          owmEventKeyEventType event_type = owmEvents_get_key_event_type(ev.code, ev.value ? true : false);
          if (owmEvents_keyboard_key_press_callback != NULL) {
            owmEvents_keyboard_key_press_callback(ev.code, event_type);
          }
        }
      }
    }

    if (device_info->type == OWM_INPUT_DEVICE_TYPE_MOUSE) {
      printf("\tMOUSE\n");
      struct input_event ev;
      static int rel_x = 0;
      static int rel_y = 0;
      while (read(fd, &ev, sizeof(ev)) == sizeof(ev)) {
        if (ev.type == EV_REL) {
          if (ev.code == REL_X) {
            rel_x += ev.value;
          } else if (ev.code == REL_Y) {
            rel_y += ev.value;
          } else if (ev.code == REL_WHEEL) {
            // TODO: handle scroll wheel
          }
        } else if (ev.type == EV_KEY) {
          owmEventKeyEventType event_type = owmEvents_get_key_event_type(ev.code, ev.value ? true : false);
          if (owmEvents_mouse_key_press_callback != NULL) {
            owmEvents_mouse_key_press_callback(ev.code, event_type);
          }
        } else if (ev.type == EV_SYN && ev.code == SYN_REPORT) { // The mouse "packet" is complete. Dispatch total movement
          if (owmEvents_mouse_move_callback != NULL) {
            owmEvents_mouse_move_callback(rel_x, rel_y);
          }
          rel_x = 0;
          rel_y = 0;
        }
      }
    }
  }
}

void owmEvents_cleanup() {
  free(OWM_EVENT_POLL_DATAS.epoll_events);
  free(OWM_EVENT_POLL_DATAS.device_infos);
}
